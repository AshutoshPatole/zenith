"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5946],{7627:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var t=n(5893),r=n(1151);const s={sidebar_position:2,slug:"/common-terms-in-operator",title:"Operator Framework (common terms)"},i=void 0,o={id:"Containers/OpenShift/common_terms",title:"Operator Framework (common terms)",description:"---",source:"@site/docs/Containers/OpenShift/common_terms.mdx",sourceDirName:"Containers/OpenShift",slug:"/common-terms-in-operator",permalink:"/zenith/common-terms-in-operator",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"AshutoshPatole18",lastUpdatedAt:1706788254,formattedLastUpdatedAt:"Feb 1, 2024",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/common-terms-in-operator",title:"Operator Framework (common terms)"},sidebar:"tutorialSidebar",previous:{title:"Commands Cheatsheet",permalink:"/zenith/frequent-commands"},next:{title:"Machine Config Pool",permalink:"/zenith/mcp"}},l={},d=[{value:"Bundle",id:"bundle",level:2},{value:"Bundle image",id:"bundle-image",level:2},{value:"Catalog source",id:"catalog-source",level:2},{value:"Catalog image",id:"catalog-image",level:2},{value:"Channel",id:"channel",level:2},{value:"Channel head",id:"channel-head",level:2},{value:"Cluster service version",id:"cluster-service-version",level:2},{value:"Dependency",id:"dependency",level:2},{value:"Index image",id:"index-image",level:2},{value:"Install plan",id:"install-plan",level:2},{value:"Operator group",id:"operator-group",level:2},{value:"Package",id:"package",level:2},{value:"Registry",id:"registry",level:2},{value:"Subscription",id:"subscription",level:2},{value:"Update graph",id:"update-graph",level:2}];function c(e){const a={a:"a",em:"em",h2:"h2",hr:"hr",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.hr,{}),"\n",(0,t.jsx)(a.h2,{id:"bundle",children:"Bundle"}),"\n",(0,t.jsxs)(a.p,{children:["In the Bundle Format, a bundle is a collection of an Operator ",(0,t.jsx)(a.a,{href:"#cluster-service-version",children:"CSV"}),", manifests, and metadata. Together, they form a unique version of an Operator that can be installed onto the cluster."]}),"\n",(0,t.jsx)(a.h2,{id:"bundle-image",children:"Bundle image"}),"\n",(0,t.jsxs)(a.p,{children:["In the Bundle Format, a bundle image is a container image that is built from Operator manifests and that contains one bundle. Bundle images are stored and distributed by ",(0,t.jsx)(a.strong,{children:"Open Container Initiative (OCI)"})," spec container registries, such as ",(0,t.jsx)(a.em,{children:"Quay.io"})," or ",(0,t.jsx)(a.em,{children:"DockerHub"}),"."]}),"\n",(0,t.jsx)(a.h2,{id:"catalog-source",children:"Catalog source"}),"\n",(0,t.jsx)(a.p,{children:"A catalog source is a repository of CSVs, CRDs, and packages that define an application."}),"\n",(0,t.jsx)(a.h2,{id:"catalog-image",children:"Catalog image"}),"\n",(0,t.jsx)(a.p,{children:"In the Package Manifest Format, a catalog image is a containerized datastore that describes a set of Operator metadata and update metadata that can be installed onto a cluster using OLM."}),"\n",(0,t.jsx)(a.h2,{id:"channel",children:"Channel"}),"\n",(0,t.jsx)(a.p,{children:"A channel defines a stream of updates for an Operator and is used to roll out updates for subscribers. The head points to the latest version of that channel. For example, a stable channel would have all stable versions of an Operator arranged from the earliest to the latest."}),"\n",(0,t.jsx)(a.p,{children:"An Operator can have several channels, and a subscription binding to a certain channel would only look for updates in that channel."}),"\n",(0,t.jsx)(a.h2,{id:"channel-head",children:"Channel head"}),"\n",(0,t.jsx)(a.p,{children:"A channel head refers to the latest known update in a particular channel."}),"\n",(0,t.jsx)(a.h2,{id:"cluster-service-version",children:"Cluster service version"}),"\n",(0,t.jsx)(a.p,{children:"A cluster service version (CSV) is a YAML manifest created from Operator metadata that assists OLM in running the Operator in a cluster. It is the metadata that accompanies an Operator container image, used to populate user interfaces with information such as its logo, description, and version."}),"\n",(0,t.jsx)(a.p,{children:"It is also a source of technical information that is required to run the Operator, like the RBAC rules it requires and which custom resources (CRs) it manages or depends on."}),"\n",(0,t.jsx)(a.h2,{id:"dependency",children:"Dependency"}),"\n",(0,t.jsx)(a.p,{children:"An Operator may have a dependency on another Operator being present in the cluster. For example, the Vault Operator has a dependency on the etcd Operator for its data persistence layer."}),"\n",(0,t.jsx)(a.p,{children:"OLM resolves dependencies by ensuring that all specified versions of Operators and CRDs are installed on the cluster during the installation phase. This dependency is resolved by finding and installing an Operator in a catalog that satisfies the required CRD API, and is not related to packages or bundles."}),"\n",(0,t.jsx)(a.h2,{id:"index-image",children:"Index image"}),"\n",(0,t.jsx)(a.p,{children:"In the Bundle Format, an index image refers to an image of a database (a database snapshot) that contains information about Operator bundles including CSVs and CRDs of all versions. This index can host a history of Operators on a cluster and be maintained by adding or removing Operators using the opm CLI tool."}),"\n",(0,t.jsx)(a.h2,{id:"install-plan",children:"Install plan"}),"\n",(0,t.jsx)(a.p,{children:"An install plan is a calculated list of resources to be created to automatically install or upgrade a CSV."}),"\n",(0,t.jsx)(a.h2,{id:"operator-group",children:"Operator group"}),"\n",(0,t.jsx)(a.p,{children:"An Operator group configures all Operators deployed in the same namespace as the OperatorGroup object to watch for their CR in a list of namespaces or cluster-wide."}),"\n",(0,t.jsx)(a.h2,{id:"package",children:"Package"}),"\n",(0,t.jsx)(a.p,{children:"In the Bundle Format, a package is a directory that encloses all released history of an Operator with each version. A released version of an Operator is described in a CSV manifest alongside the CRDs."}),"\n",(0,t.jsx)(a.h2,{id:"registry",children:"Registry"}),"\n",(0,t.jsx)(a.p,{children:"A registry is a database that stores bundle images of Operators, each with all of its latest and historical versions in all channels."}),"\n",(0,t.jsx)(a.h2,{id:"subscription",children:"Subscription"}),"\n",(0,t.jsx)(a.p,{children:"A subscription keeps CSVs up to date by tracking a channel in a package."}),"\n",(0,t.jsx)(a.h2,{id:"update-graph",children:"Update graph"}),"\n",(0,t.jsx)(a.p,{children:"An update graph links versions of CSVs together, similar to the update graph of any other packaged software. Operators can be installed sequentially, or certain versions can be skipped. The update graph is expected to grow only at the head with newer versions being added."})]})}function h(e={}){const{wrapper:a}={...(0,r.a)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1151:(e,a,n)=>{n.d(a,{Z:()=>o,a:()=>i});var t=n(7294);const r={},s=t.createContext(r);function i(e){const a=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);