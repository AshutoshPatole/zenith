"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3378],{3270:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var t=n(5893),a=n(1151);const s={sidebar_position:4,slug:"/mcp",title:"Machine Config Pool"},r=void 0,i={id:"Containers/OpenShift/machine_config_pool",title:"Machine Config Pool",description:"---",source:"@site/docs/Containers/OpenShift/machine_config_pool.mdx",sourceDirName:"Containers/OpenShift",slug:"/mcp",permalink:"/zenith/mcp",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"AshutoshPatole18",lastUpdatedAt:1706788254,formattedLastUpdatedAt:"Feb 1, 2024",sidebarPosition:4,frontMatter:{sidebar_position:4,slug:"/mcp",title:"Machine Config Pool"},sidebar:"tutorialSidebar",previous:{title:"Operator Framework (common terms)",permalink:"/zenith/common-terms-in-operator"},next:{title:"Machine Sets",permalink:"/zenith/machine-set"}},c={},d=[{value:"Node configuration management with machine config pools",id:"node-configuration-management-with-machine-config-pools",level:2}];function l(e){const o={h2:"h2",hr:"hr",p:"p",strong:"strong",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.hr,{}),"\n",(0,t.jsx)(o.p,{children:"The control plane, which is composed of control plane machines (also known as the master machines), manages the OpenShift Container Platform cluster. The control plane machines manage workloads on the compute machines, which are also known as worker machines. The cluster itself manages all upgrades to the machines by the actions of the Cluster Version Operator, the Machine Config Operator, and a set of individual Operators."}),"\n",(0,t.jsx)(o.h2,{id:"node-configuration-management-with-machine-config-pools",children:"Node configuration management with machine config pools"}),"\n",(0,t.jsx)(o.p,{children:"Machines that run control plane components or user workloads are divided into groups based on the types of resources they handle. These groups of machines are called machine config pools (MCP). Each MCP manages a set of nodes and its corresponding machine configs. The role of the node determines which MCP it belongs to; the MCP governs nodes based on its assigned node role label. Nodes in an MCP have the same configuration; this means nodes can be scaled up and torn down in response to increased or decreased workloads."}),"\n",(0,t.jsxs)(o.p,{children:["By default, there are two MCPs created by the cluster when it is installed: ",(0,t.jsx)(o.strong,{children:"master"})," and ",(0,t.jsx)(o.strong,{children:"worker"}),". Each default MCP has a defined configuration applied by the Machine Config Operator (MCO), which is responsible for managing MCPs and facilitating MCP upgrades. You can create additional MCPs, or custom pools, to manage nodes that have custom use cases that extend outside of the default node types."]}),"\n",(0,t.jsx)(o.p,{children:"It is recommended to have a custom pool for every node role you want to manage in your cluster. For example, if you create infra nodes to handle infra workloads, it is recommended to create a custom infra MCP to group those nodes together. If you apply an infra role label to a worker node so it has the worker,infra dual label, but do not have a custom infra MCP, the MCO considers it a worker node. If you remove the worker label from a node and apply the infra label without grouping it in a custom pool, the node is not recognized by the MCO and is unmanaged by the cluster."}),"\n",(0,t.jsx)(o.p,{children:"The MCO applies updates for pools independently; for example, if there is an update that affects all pools, nodes from each pool update in parallel with each other. If you add a custom pool, nodes from that pool also attempt to update concurrently with the master and worker nodes."})]})}function h(e={}){const{wrapper:o}={...(0,a.a)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,o,n)=>{n.d(o,{Z:()=>i,a:()=>r});var t=n(7294);const a={},s=t.createContext(a);function r(e){const o=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:o},e.children)}}}]);