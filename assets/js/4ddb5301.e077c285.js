"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7837],{3992:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var s=t(5893),o=t(1151);const r={sidebar_position:3,slug:"/service",title:"Service"},i=void 0,a={id:"Containers/OpenShift/Networking/service",title:"Service",description:"---",source:"@site/docs/Containers/OpenShift/Networking/service.mdx",sourceDirName:"Containers/OpenShift/Networking",slug:"/service",permalink:"/zenith/service",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"AshutoshPatole18",lastUpdatedAt:1706788254,formattedLastUpdatedAt:"Feb 1, 2024",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/service",title:"Service"},sidebar:"tutorialSidebar",previous:{title:"Communication between Nodes and the Control Plane",permalink:"/zenith/communication-between-master-and-worker-nodes"},next:{title:"Machine Config Operator",permalink:"/zenith/mco"}},c={},d=[{value:"Motivation",id:"motivation",level:3},{value:"Service resources",id:"service-resources",level:3},{value:"Defining a Service",id:"defining-a-service",level:3},{value:"Services without selectors",id:"services-without-selectors",level:3},{value:"Multi-Port Services",id:"multi-port-services",level:3},{value:"Choosing your own IP address",id:"choosing-your-own-ip-address",level:3},{value:"Publishing Services (ServiceTypes)",id:"publishing-services-servicetypes",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"An abstract way to expose an application running on a set of Pods as a network service.\nWith Kubernetes you don't need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them."}),"\n",(0,s.jsx)(n.h3,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsxs)(n.p,{children:["Kubernetes Pods are created and destroyed to match the desired state of your cluster. Pods are nonpermanent resources. If you use a ",(0,s.jsx)(n.a,{href:"/deployments",children:"Deployment"})," to run your app, it can create and destroy Pods dynamically."]}),"\n",(0,s.jsx)(n.p,{children:"Each Pod gets its own IP address, however in a Deployment, the set of Pods running in one moment in time could be different from the set of Pods running that application a moment later."}),"\n",(0,s.jsx)(n.p,{children:'This leads to a problem: if some set of Pods (call them "backends") provides functionality to other Pods (call them "frontends") inside your cluster, how do the frontends find out and keep track of which IP address to connect to, so that the frontend can use the backend part of the workload?'}),"\n",(0,s.jsx)(n.h3,{id:"service-resources",children:"Service resources"}),"\n",(0,s.jsx)(n.p,{children:"In Kubernetes, a Service is an abstraction which defines a logical set of Pods and a policy by which to access them (sometimes this pattern is called a micro-service). The set of Pods targeted by a Service is usually determined by a selector."}),"\n",(0,s.jsx)(n.p,{children:"For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves."}),"\n",(0,s.jsx)(n.p,{children:"The Service abstraction enables this decoupling."}),"\n",(0,s.jsx)(n.h3,{id:"defining-a-service",children:"Defining a Service"}),"\n",(0,s.jsx)(n.p,{children:"A Service in Kubernetes is a REST object, similar to a Pod. Like all of the REST objects, you can POST a Service definition to the API server to create a new instance."}),"\n",(0,s.jsxs)(n.p,{children:["For example, suppose you have a set of Pods where each listens on TCP port 9376 and contains a label ",(0,s.jsx)(n.code,{children:"app.kubernetes.io/name=MyApp"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app.kubernetes.io/name: MyApp\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 9376\n"})}),"\n",(0,s.jsxs)(n.p,{children:['This specification creates a new Service object named "my-service", which targets TCP port 9376 on any Pod with the ',(0,s.jsx)(n.code,{children:"app.kubernetes.io/name=MyApp"}),' label.\nKubernetes assigns this Service an IP address (sometimes called the "cluster IP"), which is used by the Service proxies']}),"\n",(0,s.jsx)(n.p,{children:'The controller for the Service selector continuously scans for Pods that match its selector, and then POSTs any updates to an Endpoint object also named "my-service".'}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["A Service can map any incoming ",(0,s.jsx)(n.code,{children:"port"})," to a ",(0,s.jsx)(n.code,{children:"targetPort"}),". By default and for convenience, the ",(0,s.jsx)(n.code,{children:"targetPort"})," is set to the same value as the ",(0,s.jsx)(n.code,{children:"port"})," field."]})}),"\n",(0,s.jsx)(n.h3,{id:"services-without-selectors",children:"Services without selectors"}),"\n",(0,s.jsx)(n.p,{children:"Services most commonly abstract access to Kubernetes Pods thanks to the selector, but when used with a corresponding Endpoints object and without a selector, the Service can abstract other kinds of backends, including ones that run outside the cluster. For example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You want to have an external database cluster in production, but in your test environment you use your own databases."}),"\n",(0,s.jsx)(n.li,{children:"You want to point your Service to a Service in a different Namespace or on another cluster."}),"\n",(0,s.jsx)(n.li,{children:"You are migrating a workload to Kubernetes. While evaluating the approach, you run only a portion of your backends in Kubernetes."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In any of these scenarios you can define a Service without a Pod selector. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 9376\n"})}),"\n",(0,s.jsx)(n.p,{children:"Because this Service has no selector, the corresponding Endpoints object is not created automatically. You can manually map the Service to the network address and port where it's running, by adding an Endpoints object manually:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Endpoints\nmetadata:\n  # the name here should match the name of the Service\n  name: my-service\nsubsets:\n  - addresses:\n      - ip: 192.0.2.42\n    ports:\n      - port: 9376\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The name of the Endpoints object must be a valid DNS subdomain name."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When you create an Endpoints object for a Service, you set the name of the new object to be the same as that of the Service."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Accessing a Service without a selector works the same as if it had a selector. In the example above, traffic is routed to the single endpoint defined in the YAML: ",(0,s.jsx)(n.code,{children:"192.0.2.42:9376"})," (TCP)."]}),"\n",(0,s.jsx)(n.h3,{id:"multi-port-services",children:"Multi-Port Services"}),"\n",(0,s.jsx)(n.p,{children:"For some Services, you need to expose more than one port. Kubernetes lets you configure multiple port definitions on a Service object. When using multiple ports for a Service, you must give all of your ports names so that these are unambiguous. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app.kubernetes.io/name: MyApp\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n      targetPort: 9376\n    - name: https\n      protocol: TCP\n      port: 443\n      targetPort: 9377\n"})}),"\n",(0,s.jsx)(n.h3,{id:"choosing-your-own-ip-address",children:"Choosing your own IP address"}),"\n",(0,s.jsxs)(n.p,{children:["You can specify your own cluster IP address as part of a Service creation request. To do this, set the ",(0,s.jsx)(n.code,{children:".spec.clusterIP"})," field. For example, if you already have an existing DNS entry that you wish to reuse, or legacy systems that are configured for a specific IP address and difficult to re-configure."]}),"\n",(0,s.jsxs)(n.p,{children:["The IP address that you choose must be a valid IPv4 or IPv6 address from within the ",(0,s.jsx)(n.code,{children:"service-cluster-ip-range"})," CIDR range that is configured for the API server. If you try to create a Service with an invalid clusterIP address value, the API server will return a 422 HTTP status code to indicate that there's a problem."]}),"\n",(0,s.jsx)(n.h3,{id:"publishing-services-servicetypes",children:"Publishing Services (ServiceTypes)"}),"\n",(0,s.jsx)(n.p,{children:"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that's outside of your cluster."}),"\n",(0,s.jsxs)(n.p,{children:["Kubernetes ",(0,s.jsx)(n.code,{children:"ServiceTypes"})," allow you to specify what kind of Service you want. The default is ",(0,s.jsx)(n.code,{children:"ClusterIP"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Type"})," values and their behaviors are:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClusterIP"}),": Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NodePort"}),": Exposes the Service on each Node's IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You'll be able to contact the NodePort Service, from outside the cluster, by requesting ",(0,s.jsx)(n.code,{children:"<NodeIP>:<NodePort>"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"LoadBalancer"}),": Exposes the Service externally using a cloud provider's load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>i});var s=t(7294);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);