"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5557],{9327:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var o=t(5893),i=t(1151);const r={sidebar_position:2,slug:"/node-controller",title:"Node Controller"},s=void 0,l={id:"Containers/OpenShift/Controllers/node_controller",title:"Node Controller",description:"---",source:"@site/docs/Containers/OpenShift/Controllers/node_controller.mdx",sourceDirName:"Containers/OpenShift/Controllers",slug:"/node-controller",permalink:"/zenith/node-controller",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"AshutoshPatole18",lastUpdatedAt:1706788254,formattedLastUpdatedAt:"Feb 1, 2024",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/node-controller",title:"Node Controller"},sidebar:"tutorialSidebar",previous:{title:"What is Controller ?",permalink:"/zenith/what-is-controller"},next:{title:"Replication Controller",permalink:"/zenith/replication-controller"}},a={},d=[{value:"Rate limits on eviction",id:"rate-limits-on-eviction",level:3}];function c(e){const n={code:"code",h3:"h3",hr:"hr",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"The node controller is a Kubernetes control plane component that manages various aspects of nodes."}),"\n",(0,o.jsx)(n.p,{children:"The node controller has multiple roles in a node's life. The first is assigning a CIDR block to the node when it is registered (if CIDR assignment is turned on)."}),"\n",(0,o.jsx)(n.p,{children:"The second is keeping the node controller's internal list of nodes up to date with the cloud provider's list of available machines. When running in a cloud environment and whenever a node is unhealthy, the node controller asks the cloud provider if the VM for that node is still available. If not, the node controller deletes the node from its list of nodes."}),"\n",(0,o.jsx)(n.p,{children:"The third is monitoring the nodes' health. The node controller is responsible for:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["In the case that a node becomes unreachable, updating the Ready condition in the Node's ",(0,o.jsx)(n.code,{children:".status"})," field. In this case the node controller sets the ",(0,o.jsx)(n.code,{children:"Ready"})," condition to ",(0,o.jsx)(n.code,{children:"Unknown"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["If a node remains unreachable: triggering API-initiated eviction for all of the Pods on the unreachable node. By default, the node controller waits 5 minutes between marking the node as ",(0,o.jsx)(n.code,{children:"Unknown"})," and submitting the first eviction request."]}),"\n",(0,o.jsxs)(n.li,{children:["By default, the node controller checks the state of each node every 5 seconds. This period can be configured using the ",(0,o.jsx)(n.code,{children:"--node-monitor-period"})," flag on the kube-controller-manager component."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"rate-limits-on-eviction",children:"Rate limits on eviction"}),"\n",(0,o.jsxs)(n.p,{children:["In most cases, the node controller limits the eviction rate to ",(0,o.jsx)(n.code,{children:"--node-eviction-rate"})," (default 0.1) per second, meaning it won't evict pods from more than 1 node per 10 seconds."]}),"\n",(0,o.jsxs)(n.p,{children:["The node eviction behavior changes when a node in a given availability zone becomes unhealthy. The node controller checks what percentage of nodes in the zone are unhealthy (the Ready condition is ",(0,o.jsx)(n.code,{children:"Unknown"})," or ",(0,o.jsx)(n.code,{children:"False"}),") at the same time:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If the fraction of unhealthy nodes is at least ",(0,o.jsx)(n.code,{children:"--unhealthy-zone-threshold"})," (default 0.55), then the eviction rate is reduced."]}),"\n",(0,o.jsxs)(n.li,{children:["If the cluster is small (i.e. has less than or equal to ",(0,o.jsx)(n.code,{children:"--large-cluster-size-threshold nodes"})," - default 50), then evictions are stopped."]}),"\n",(0,o.jsxs)(n.li,{children:["Otherwise, the eviction rate is reduced to ",(0,o.jsx)(n.code,{children:"--secondary-node-eviction-rate"})," (default 0.01) per second."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The reason these policies are implemented per availability zone is because one availability zone might become partitioned from the control plane while the others remain connected. If your cluster does not span multiple cloud provider availability zones, then the eviction mechanism does not take per-zone unavailability into account."}),"\n",(0,o.jsxs)(n.p,{children:["A key reason for spreading your nodes across availability zones is so that the workload can be shifted to healthy zones when one entire zone goes down. Therefore, if all nodes in a zone are unhealthy, then the node controller evicts at the normal rate of ",(0,o.jsx)(n.code,{children:"--node-eviction-rate"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>s});var o=t(7294);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);