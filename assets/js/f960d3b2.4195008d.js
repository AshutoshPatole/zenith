"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7286],{8840:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var s=n(5893),t=n(1151);const i={sidebar_position:6,slug:"/job",title:"Jobs"},l=void 0,a={id:"Containers/OpenShift/Workloads/job",title:"Jobs",description:"---",source:"@site/docs/Containers/OpenShift/Workloads/job.mdx",sourceDirName:"Containers/OpenShift/Workloads",slug:"/job",permalink:"/zenith/job",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"AshutoshPatole18",lastUpdatedAt:1706788254,formattedLastUpdatedAt:"Feb 1, 2024",sidebarPosition:6,frontMatter:{sidebar_position:6,slug:"/job",title:"Jobs"},sidebar:"tutorialSidebar",previous:{title:"Init Containers",permalink:"/zenith/init-container"},next:{title:"CronJobs",permalink:"/zenith/cron-job"}},r={},c=[{value:"Running an example Job",id:"running-an-example-job",level:3},{value:"Parallel execution for Jobs",id:"parallel-execution-for-jobs",level:3},{value:"Controlling parallelism",id:"controlling-parallelism",level:3},{value:"Pod backoff failure policy",id:"pod-backoff-failure-policy",level:3},{value:"Automatic Clean-up for Finished Jobs",id:"automatic-clean-up-for-finished-jobs",level:3}];function d(e){const o={code:"code",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.hr,{}),"\n",(0,s.jsx)(o.p,{children:"A Job creates one or more Pods and will continue to retry execution of the Pods until a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. Suspending a Job will delete its active Pods until the Job is resumed again."}),"\n",(0,s.jsx)(o.p,{children:"A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot)."}),"\n",(0,s.jsx)(o.p,{children:"You can also use a Job to run multiple Pods in parallel."}),"\n",(0,s.jsx)(o.h3,{id:"running-an-example-job",children:"Running an example Job"}),"\n",(0,s.jsxs)(o.p,{children:["Here is an example Job config. It computes ",(0,s.jsx)(o.code,{children:"\u03c0"})," to 2000 places and prints it out. It takes around 10s to complete."]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-yaml",metastring:'title="job.yaml"',children:'apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: pi\nspec:\n  template:\n    spec:\n      containers:\n      - name: pi\n        image: perl:5.34\n        command: ["perl",  "-Mbignum=bpi", "-wle", "\'print bpi(2000)\'"]\n      restartPolicy: Never\n  backoffLimit: 4\n'})}),"\n",(0,s.jsx)(o.p,{children:"You can run the example with this command:"}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{children:"oc apply -f job.yaml\n"})}),"\n",(0,s.jsx)(o.p,{children:"The output is similar to this:"}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{children:"job.batch/pi created\n"})}),"\n",(0,s.jsxs)(o.p,{children:["To view completed Pods of a Job, use ",(0,s.jsx)(o.code,{children:"oc get pods"}),"."]}),"\n",(0,s.jsx)(o.p,{children:"To list all the Pods that belong to a Job in a machine readable form, you can use a command like this:"}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{children:"oc get pods --selector=job-name=pi --output=jsonpath='{.items[*].metadata.name}'\n"})}),"\n",(0,s.jsx)(o.p,{children:"View the standard output of one of the pods:"}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{children:"oc logs $pods\n"})}),"\n",(0,s.jsx)(o.p,{children:"The output is similar to this:"}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{children:"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901\n"})}),"\n",(0,s.jsx)(o.h3,{id:"parallel-execution-for-jobs",children:"Parallel execution for Jobs"}),"\n",(0,s.jsx)(o.p,{children:"There are three main types of task suitable to run as a Job:"}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsxs)(o.li,{children:["Non-parallel Jobs","\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:"normally, only one Pod is started, unless the Pod fails."}),"\n",(0,s.jsx)(o.li,{children:"the Job is complete as soon as its Pod terminates successfully."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["Parallel Jobs with a fixed completion count:","\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["specify a non-zero positive value for ",(0,s.jsx)(o.code,{children:".spec.completions"}),"."]}),"\n",(0,s.jsxs)(o.li,{children:["the Job represents the overall task, and is complete when there are ",(0,s.jsx)(o.code,{children:".spec.completions"})," successful Pods."]}),"\n",(0,s.jsxs)(o.li,{children:['when using .spec.completionMode="Indexed", each Pod gets a different index in the range 0 to ',(0,s.jsx)(o.code,{children:".spec.completions-1"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["Parallel Jobs with a work queue:","\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["do not specify ",(0,s.jsx)(o.code,{children:".spec.completions"}),", default to ",(0,s.jsx)(o.code,{children:".spec.parallelism"}),"."]}),"\n",(0,s.jsx)(o.li,{children:"the Pods must coordinate amongst themselves or an external service to determine what each should work on. For example, a Pod might fetch a batch of up to N items from the work queue.\neach Pod is independently capable of determining whether or not all its peers are done, and thus that the entire Job is done."}),"\n",(0,s.jsx)(o.li,{children:"when any Pod from the Job terminates with success, no new Pods are created."}),"\n",(0,s.jsx)(o.li,{children:"once at least one Pod has terminated with success and all Pods are terminated, then the Job is completed with success."}),"\n",(0,s.jsx)(o.li,{children:"once any Pod has exited with success, no other Pod should still be doing any work for this task or writing any output. They should all be in the process of exiting."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(o.p,{children:["For a non-parallel Job, you can leave both ",(0,s.jsx)(o.code,{children:".spec.completions"})," and ",(0,s.jsx)(o.code,{children:".spec.parallelism"})," unset. When both are unset, both are defaulted to 1."]}),"\n",(0,s.jsxs)(o.p,{children:["For a fixed completion count Job, you should set ",(0,s.jsx)(o.code,{children:".spec.completions"})," to the number of completions needed. You can set ",(0,s.jsx)(o.code,{children:".spec.parallelism"}),", or leave it unset and it will default to 1."]}),"\n",(0,s.jsxs)(o.p,{children:["For a work queue Job, you must leave ",(0,s.jsx)(o.code,{children:".spec.completions"})," unset, and set ",(0,s.jsx)(o.code,{children:".spec.parallelism"})," to a non-negative integer."]}),"\n",(0,s.jsx)(o.h3,{id:"controlling-parallelism",children:"Controlling parallelism"}),"\n",(0,s.jsxs)(o.p,{children:["The requested parallelism (",(0,s.jsx)(o.code,{children:".spec.parallelism"}),") can be set to any non-negative value. If it is unspecified, it defaults to 1. If it is specified as 0, then the Job is effectively paused until it is increased."]}),"\n",(0,s.jsx)(o.p,{children:"Actual parallelism (number of pods running at any instant) may be more or less than requested parallelism, for a variety of reasons:"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["For fixed completion count Jobs, the actual number of pods running in parallel will not exceed the number of remaining completions. Higher values of ",(0,s.jsx)(o.code,{children:".spec.parallelism"})," are effectively ignored."]}),"\n",(0,s.jsx)(o.li,{children:"For work queue Jobs, no new Pods are started after any Pod has succeeded -- remaining Pods are allowed to complete, however."}),"\n",(0,s.jsx)(o.li,{children:"If the Job Controller has not had time to react."}),"\n",(0,s.jsx)(o.li,{children:"If the Job controller failed to create Pods for any reason (lack of ResourceQuota, lack of permission, etc.), then there may be fewer pods than requested."}),"\n",(0,s.jsx)(o.li,{children:"The Job controller may throttle new Pod creation due to excessive previous pod failures in the same Job."}),"\n",(0,s.jsx)(o.li,{children:"When a Pod is gracefully shut down, it takes time to stop."}),"\n"]}),"\n",(0,s.jsx)(o.h3,{id:"pod-backoff-failure-policy",children:"Pod backoff failure policy"}),"\n",(0,s.jsxs)(o.p,{children:["There are situations where you want to fail a Job after some amount of retries due to a logical error in configuration etc. To do so, set ",(0,s.jsx)(o.code,{children:".spec.backoffLimit"})," to specify the number of retries before considering a Job as failed. The back-off limit is set by default to 6. Failed Pods associated with the Job are recreated by the Job controller with an exponential back-off delay (10s, 20s, 40s ...) capped at ",(0,s.jsx)(o.strong,{children:"six minutes"}),"."]}),"\n",(0,s.jsx)(o.p,{children:"The number of retries is calculated in two ways:"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["The number of Pods with ",(0,s.jsx)(o.code,{children:'.status.phase = "Failed"'}),"."]}),"\n",(0,s.jsxs)(o.li,{children:['When using restartPolicy = "OnFailure", the number of retries in all the containers of Pods with ',(0,s.jsx)(o.code,{children:".status.phase"})," equal to ",(0,s.jsx)(o.code,{children:"Pending"})," or ",(0,s.jsx)(o.code,{children:"Running"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(o.p,{children:["If either of the calculations reaches the ",(0,s.jsx)(o.code,{children:".spec.backoffLimit"}),", the Job is considered failed."]}),"\n",(0,s.jsx)(o.h3,{id:"automatic-clean-up-for-finished-jobs",children:"Automatic Clean-up for Finished Jobs"}),"\n",(0,s.jsx)(o.p,{children:"When a Job completes, no more Pods are created, but the Pods are usually not deleted either. Keeping them around allows you to still view the logs of completed pods to check for errors, warnings, or other diagnostic output. The job object also remains after it is completed so that you can view its status. It is up to the user to delete old jobs after noting their status."}),"\n",(0,s.jsxs)(o.p,{children:["Another way to terminate a Job is by setting an active deadline. Do this by setting the ",(0,s.jsx)(o.code,{children:".spec.activeDeadlineSeconds"})," field of the Job to a number of seconds. The ",(0,s.jsx)(o.code,{children:"activeDeadlineSeconds"})," applies to the duration of the job, no matter how many Pods are created. Once a Job reaches ",(0,s.jsx)(o.code,{children:"activeDeadlineSeconds"}),", all of its running Pods are terminated and the Job status will become type: ",(0,s.jsx)(o.code,{children:"Failed with reason: DeadlineExceeded"}),"."]}),"\n",(0,s.jsxs)(o.p,{children:["Note that a Job's ",(0,s.jsx)(o.code,{children:".spec.activeDeadlineSeconds"})," takes precedence over its ",(0,s.jsx)(o.code,{children:".spec.backoffLimit"}),". Therefore, a Job that is retrying one or more failed Pods will not deploy additional Pods once it reaches the time limit specified by ",(0,s.jsx)(o.code,{children:"activeDeadlineSeconds"}),", even if the ",(0,s.jsx)(o.code,{children:"backoffLimit"})," is not yet reached."]}),"\n",(0,s.jsxs)(o.p,{children:["Finished Jobs are usually no longer needed in the system. Keeping them around in the system will put pressure on the API server. If the Jobs are managed directly by a higher level controller, such as ",(0,s.jsx)(o.code,{children:"CronJobs"}),", the Jobs can be cleaned up by CronJobs based on the specified capacity-based cleanup policy."]})]})}function h(e={}){const{wrapper:o}={...(0,t.a)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,o,n)=>{n.d(o,{Z:()=>a,a:()=>l});var s=n(7294);const t={},i=s.createContext(t);function l(e){const o=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:o},e.children)}}}]);