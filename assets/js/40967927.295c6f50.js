"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7222],{8646:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var o=t(5893),r=t(1151);const i={sidebar_position:3,slug:"/communication-between-master-and-worker-nodes",title:"Communication between Nodes and the Control Plane"},s=void 0,c={id:"Containers/OpenShift/Networking/communication_between_nodes",title:"Communication between Nodes and the Control Plane",description:"---",source:"@site/docs/Containers/OpenShift/Networking/communication_between_nodes.mdx",sourceDirName:"Containers/OpenShift/Networking",slug:"/communication-between-master-and-worker-nodes",permalink:"/zenith/communication-between-master-and-worker-nodes",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"AshutoshPatole18",lastUpdatedAt:1706788254,formattedLastUpdatedAt:"Feb 1, 2024",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/communication-between-master-and-worker-nodes",title:"Communication between Nodes and the Control Plane"},sidebar:"tutorialSidebar",previous:{title:"Basic Network Understanding",permalink:"/zenith/basic-network-understanding"},next:{title:"Service",permalink:"/zenith/service"}},a={},d=[{value:"Node to Control Plane",id:"node-to-control-plane",level:3},{value:"Control plane to node",id:"control-plane-to-node",level:3},{value:"API server to kubelet",id:"api-server-to-kubelet",level:4},{value:"API server to nodes, pods, and services",id:"api-server-to-nodes-pods-and-services",level:4},{value:"SSH tunnels",id:"ssh-tunnels",level:3}];function l(e){const n={admonition:"admonition",code:"code",em:"em",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h3,{id:"node-to-control-plane",children:"Node to Control Plane"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Kubernetes has a ",(0,o.jsx)(n.strong,{children:'"hub-and-spoke"'})," API pattern. All API usage from nodes (or the pods they run) terminates at the API server. None of the other control plane components are designed to expose remote services. The API server is configured to listen for remote connections on a secure HTTPS port (typically 443) with one or more forms of client authentication enabled. One or more forms of authorization should be enabled, especially if ",(0,o.jsx)(n.code,{children:"anonymous"})," requests or ",(0,o.jsx)(n.code,{children:"service account tokens"})," are allowed."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Nodes should be provisioned with the public root certificate for the cluster such that they can connect securely to the API server along with valid client credentials. A good approach is that the client credentials provided to the kubelet are in the form of a client certificate."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Pods that wish to connect to the API server can do so securely by leveraging a service account so that Kubernetes will automatically inject the public root certificate and a valid bearer token into the pod when it is instantiated. The ",(0,o.jsx)(n.code,{children:"kubernetes"})," service (in ",(0,o.jsx)(n.code,{children:"default"})," namespace) is configured with a virtual IP address that is redirected (via ",(0,o.jsx)(n.code,{children:"kube-proxy"}),") to the HTTPS endpoint on the API server."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The control plane components also communicate with the API server over the secure port."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"As a result, the default operating mode for connections from the nodes and pods running on the nodes to the control plane is secured by default and can run over untrusted and/or public networks."}),"\n",(0,o.jsx)(n.h3,{id:"control-plane-to-node",children:"Control plane to node"}),"\n",(0,o.jsxs)(n.p,{children:["There are two primary communication paths from the control plane (the API server) to the nodes. The first is from the API server to the kubelet process which runs on each node in the cluster. The second is from the API server to any node, pod, or service through the API server's ",(0,o.jsx)(n.em,{children:"proxy"})," functionality."]}),"\n",(0,o.jsx)(n.h4,{id:"api-server-to-kubelet",children:"API server to kubelet"}),"\n",(0,o.jsx)(n.p,{children:"The connections from the API server to the kubelet are used for:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Fetching logs for pods."}),"\n",(0,o.jsx)(n.li,{children:"Attaching (usually through kubectl) to running pods."}),"\n",(0,o.jsx)(n.li,{children:"Providing the kubelet's port-forwarding functionality."}),"\n",(0,o.jsx)(n.li,{children:"These connections terminate at the kubelet's HTTPS endpoint. By default, the API server does not verify the kubelet's serving certificate, which makes the connection subject to man-in-the-middle attacks and unsafe to run over untrusted and/or public networks."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["To verify this connection, use the ",(0,o.jsx)(n.code,{children:"--kubelet-certificate-authority"})," flag to provide the API server with a root certificate bundle to use to verify the kubelet's serving certificate."]}),"\n",(0,o.jsx)(n.h4,{id:"api-server-to-nodes-pods-and-services",children:"API server to nodes, pods, and services"}),"\n",(0,o.jsxs)(n.p,{children:["The connections from the API server to a node, pod, or service default to plain HTTP connections and are therefore neither authenticated nor encrypted. They can be run over a secure HTTPS connection by prefixing ",(0,o.jsx)(n.code,{children:"https:"})," to the node, pod, or service name in the API URL, but they will not validate the certificate provided by the HTTPS endpoint nor provide client credentials. So while the connection will be encrypted, it will not provide any guarantees of integrity. These connections are ",(0,o.jsx)(n.strong,{children:"not currently safe"}),"  to run over untrusted or public networks."]}),"\n",(0,o.jsx)(n.h3,{id:"ssh-tunnels",children:"SSH tunnels"}),"\n",(0,o.jsx)(n.p,{children:"Kubernetes supports SSH tunnels to protect the control plane to nodes communication paths. In this configuration, the API server initiates an SSH tunnel to each node in the cluster (SSH server listening on port 22) and passes all traffic destined for a kubelet, node, pod, or service through the tunnel. This tunnel ensures that the traffic is not exposed outside of the network in which the nodes are running."}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["SSH tunnels are currently deprecated. The ",(0,o.jsx)(n.code,{children:"Konnectivity"})," service is a replacement for this communication channel."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>s});var o=t(7294);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);