"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[771],{1744:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=r(5893),t=r(1151);const a={sidebar_position:1,sidebar_label:"AWK",slug:"/awk",author:"Ashutosh Patole",tags:["grep","awk","linux"]},s="AWK",l={id:"Linux/Commands/AWK",title:"AWK",description:"AWK (awk) is a domain-specific language designed for text processing and typically used as a data extraction and reporting tool. Similar to the Sed and Grep commands, it is a filter, and is a standard feature of most Unix-like operating systems, like [[command]].",source:"@site/docs/Linux/Commands/AWK.mdx",sourceDirName:"Linux/Commands",slug:"/awk",permalink:"/awk",draft:!1,unlisted:!1,tags:[{label:"grep",permalink:"/tags/grep"},{label:"awk",permalink:"/tags/awk"},{label:"linux",permalink:"/tags/linux"}],version:"current",lastUpdatedBy:"AshutoshPatole18",lastUpdatedAt:1706524646,formattedLastUpdatedAt:"Jan 29, 2024",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"AWK",slug:"/awk",author:"Ashutosh Patole",tags:["grep","awk","linux"]},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/linux-intro"},next:{title:"Foreground and Background jobs",permalink:"/fg-and-bg"}},o={},c=[{value:"Usage",id:"usage",level:2},{value:"Unix/Linux",id:"unixlinux",level:3},{value:"Win",id:"win",level:3},{value:"Handy one-line Awk scripts",id:"handy-one-line-awk-scripts",level:2},{value:"File Spacing",id:"file-spacing",level:3},{value:"Numbering and Calculations",id:"numbering-and-calculations",level:3},{value:"String Creation",id:"string-creation",level:3},{value:"Array Creation",id:"array-creation",level:3},{value:"Text Conversion and Substitution",id:"text-conversion-and-substitution",level:3},{value:"Selective Printing of Certain Lines",id:"selective-printing-of-certain-lines",level:3},{value:"Selective Deletion of Certain Lines",id:"selective-deletion-of-certain-lines",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"awk",children:"AWK"}),"\n",(0,i.jsx)(n.p,{children:"AWK (awk) is a domain-specific language designed for text processing and typically used as a data extraction and reporting tool. Similar to the Sed and Grep commands, it is a filter, and is a standard feature of most Unix-like operating systems, like [[command]]."}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.h3,{id:"unixlinux",children:"Unix/Linux"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"awk '/pattern/ {print \"$1\"}'    # standard Unix shells\n"})}),"\n",(0,i.jsx)(n.h3,{id:"win",children:"Win"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'awk "/pattern/ {print \\"$1\\"}"  # GnuWin32, UnxUtils, Mingw\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note that the DJGPP compilation (for DOS or Windows-32) permits an awk\r\nscript to follow Unix quoting syntax ",(0,i.jsx)(n.code,{children:"'/like/ {\"this\"}'"}),". HOWEVER, if the\r\ncommand interpreter is ",(0,i.jsx)(n.code,{children:"CMD.EXE"})," or ",(0,i.jsx)(n.code,{children:"COMMAND.COM"}),", single quotes will not\r\nprotect the redirection arrows ",(0,i.jsx)(n.code,{children:"(<, >)"})," nor do they protect pipes ",(0,i.jsx)(n.code,{children:"(|)"}),'.\r\nThese are special symbols which require "double quotes" to protect them\r\nfrom interpretation as operating system directives. If the command\r\ninterpreter is bash, ksh, zsh or another Unix shell, then single and double\r\nquotes will follow the standard Unix usage.']}),"\n",(0,i.jsxs)(n.p,{children:["Users of MS-DOS or Microsoft Windows must remember that the percent\r\nsign ",(0,i.jsx)(n.code,{children:"(%)"})," is used to indicate environment variables, so this symbol must\r\nbe doubled ",(0,i.jsx)(n.code,{children:"(%%)"})," to yield a single percent sign visible to awk."]}),"\n",(0,i.jsxs)(n.p,{children:["To conserve space, use ",(0,i.jsx)(n.code,{children:"'1'"})," instead of ",(0,i.jsx)(n.code,{children:"'{print}'"})," to print each line.\r\nEither one will work."]}),"\n",(0,i.jsx)(n.h2,{id:"handy-one-line-awk-scripts",children:"Handy one-line Awk scripts"}),"\n",(0,i.jsx)(n.h3,{id:"file-spacing",children:"File Spacing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:" # double space a file\r\n awk '1;{print \"\"}'\r\n awk 'BEGIN{ORS=\"\\n\\n\"};1'\r\n\r\n # double space a file which already has blank lines in it. Output file\r\n # should contain no more than one blank line between lines of text.\r\n # NOTE: On Unix systems, DOS lines which have only CRLF (\\r\\n) are\r\n # often treated as non-blank, and thus 'NF' alone will return TRUE.\r\n awk 'NF{print $0 \"\\n\"}'\r\n\r\n # triple space a file\r\n awk '1;{print \"\\n\"}'\n"})}),"\n",(0,i.jsx)(n.h3,{id:"numbering-and-calculations",children:"Numbering and Calculations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:" # precede each line by its line number FOR THAT FILE (left alignment).\r\n # Using a tab (\\t) instead of space will preserve margins.\r\n awk '{print FNR \"\\t\" $0}' files*\r\n\r\n # precede each line by its line number FOR ALL FILES TOGETHER, with tab.\r\n awk '{print NR \"\\t\" $0}' files*\r\n\r\n # number each line of a file (number on left, right-aligned)\r\n # Double the percent signs if typing from the DOS command prompt.\r\n awk '{printf(\"%5d : %s\\n\", NR,$0)}'\r\n\r\n # number each line of file, but only print numbers if line is not blank\r\n # Remember caveats about Unix treatment of \\r (mentioned above)\r\n awk 'NF{$0=++a \" :\" $0};1'\r\n awk '{print (NF? ++a \" :\" :\"\") $0}'\r\n\r\n # count lines (emulates \"wc -l\")\r\n awk 'END{print NR}'\r\n\r\n # print the sums of the fields of every line\r\n awk '{s=0; for (i=1; i<=NF; i++) s=s+$i; print s}'\r\n\r\n # add all fields in all lines and print the sum\r\n awk '{for (i=1; i<=NF; i++) s=s+$i}; END{print s}'\r\n\r\n # print every line after replacing each field with its absolute value\r\n awk '{for (i=1; i<=NF; i++) if ($i < 0) $i = -$i; print }'\r\n awk '{for (i=1; i<=NF; i++) $i = ($i < 0) ? -$i : $i; print }'\r\n\r\n # print the total number of fields (\"words\") in all lines\r\n awk '{ total = total + NF }; END {print total}' file\r\n\r\n # print the total number of lines that contain \"Beth\"\r\n awk '/Beth/{n++}; END {print n+0}' file\r\n\r\n # print the largest first field and the line that contains it\r\n # Intended for finding the longest string in field #1\r\n awk '$1 > max {max=$1; maxline=$0}; END{ print max, maxline}'\r\n\r\n # print the number of fields in each line, followed by the line\r\n awk '{ print NF \":\" $0 } '\r\n\r\n # print the last field of each line\r\n awk '{ print $NF }'\r\n\r\n # print the last field of the last line\r\n awk '{ field = $NF }; END{ print field }'\r\n\r\n # print every line with more than 4 fields\r\n awk 'NF > 4'\r\n\r\n # print every line where the value of the last field is > 4\r\n awk '$NF > 4'\n"})}),"\n",(0,i.jsx)(n.h3,{id:"string-creation",children:"String Creation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:' # create a string of a specific length (e.g., generate 513 spaces)\r\n awk \'BEGIN{while (a++<513) s=s " "; print s}\'\r\n\r\n # insert a string of specific length at a certain character position\r\n # Example: insert 49 spaces after column #6 of each input line.\r\n gawk --re-interval \'BEGIN{while(a++<49)s=s " "};{sub(/^.{6}/,"&" s)};1\'\n'})}),"\n",(0,i.jsx)(n.h3,{id:"array-creation",children:"Array Creation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:' # These next 2 entries are not one-line scripts, but the technique\r\n # is so handy that it merits inclusion here.\r\n \r\n # create an array named "month", indexed by numbers, so that month[1]\r\n # is \'Jan\', month[2] is \'Feb\', month[3] is \'Mar\' and so on.\r\n split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", month, " ")\r\n\r\n # create an array named "mdigit", indexed by strings, so that\r\n # mdigit["Jan"] is 1, mdigit["Feb"] is 2, etc. Requires "month" array\r\n for (i=1; i<=12; i++) mdigit[month[i]] = i\n'})}),"\n",(0,i.jsx)(n.h3,{id:"text-conversion-and-substitution",children:"Text Conversion and Substitution"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:' # IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format\r\n awk \'{sub(/\\r$/,"")};1\'   # assumes EACH line ends with Ctrl-M\r\n\r\n # IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format\r\n awk \'{sub(/$/,"\\r")};1\'\r\n\r\n # IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format\r\n awk 1\r\n\r\n # IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format\r\n # Cannot be done with DOS versions of awk, other than gawk:\r\n gawk -v BINMODE="w" \'1\' infile >outfile\r\n\r\n # Use "tr" instead.\r\n tr -d \\r <infile >outfile            # GNU tr version 1.22 or higher\r\n\r\n # delete leading whitespace (spaces, tabs) from front of each line\r\n # aligns all text flush left\r\n awk \'{sub(/^[ \\t]+/, "")};1\'\r\n\r\n # delete trailing whitespace (spaces, tabs) from end of each line\r\n awk \'{sub(/[ \\t]+$/, "")};1\'\r\n\r\n # delete BOTH leading and trailing whitespace from each line\r\n awk \'{gsub(/^[ \\t]+|[ \\t]+$/,"")};1\'\r\n awk \'{$1=$1};1\'           # also removes extra space between fields\r\n\r\n # insert 5 blank spaces at beginning of each line (make page offset)\r\n awk \'{sub(/^/, "     ")};1\'\r\n\r\n # align all text flush right on a 79-column width\r\n awk \'{printf "%79s\\n", $0}\' file*\r\n\r\n # center all text on a 79-character width\r\n awk \'{l=length();s=int((79-l)/2); printf "%"(s+l)"s\\n",$0}\' file*\r\n\r\n # substitute (find and replace) "foo" with "bar" on each line\r\n awk \'{sub(/foo/,"bar")}; 1\'           # replace only 1st instance\r\n gawk \'{$0=gensub(/foo/,"bar",4)}; 1\'  # replace only 4th instance\r\n awk \'{gsub(/foo/,"bar")}; 1\'          # replace ALL instances in a line\r\n\r\n # substitute "foo" with "bar" ONLY for lines which contain "baz"\r\n awk \'/baz/{gsub(/foo/, "bar")}; 1\'\r\n\r\n # substitute "foo" with "bar" EXCEPT for lines which contain "baz"\r\n awk \'!/baz/{gsub(/foo/, "bar")}; 1\'\r\n\r\n # change "scarlet" or "ruby" or "puce" to "red"\r\n awk \'{gsub(/scarlet|ruby|puce/, "red")}; 1\'\r\n\r\n # reverse order of lines (emulates "tac")\r\n awk \'{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }\' file*\r\n\r\n # if a line ends with a backslash, append the next line to it (fails if\r\n # there are multiple lines ending with backslash...)\r\n awk \'/\\\\$/ {sub(/\\\\$/,""); getline t; print $0 t; next}; 1\' file*\r\n\r\n # print and sort the login names of all users\r\n awk -F ":" \'{print $1 | "sort" }\' /etc/passwd\r\n\r\n # print the first 2 fields, in opposite order, of every line\r\n awk \'{print $2, $1}\' file\r\n\r\n # switch the first 2 fields of every line\r\n awk \'{temp = $1; $1 = $2; $2 = temp}\' file\r\n\r\n # print every line, deleting the second field of that line\r\n awk \'{ $2 = ""; print }\'\r\n\r\n # print in reverse order the fields of every line\r\n awk \'{for (i=NF; i>0; i--) printf("%s ",$i);print ""}\' file\r\n\r\n # concatenate every 5 lines of input, using a comma separator\r\n # between fields\r\n awk \'ORS=NR%5?",":"\\n"\' file\n'})}),"\n",(0,i.jsx)(n.h3,{id:"selective-printing-of-certain-lines",children:"Selective Printing of Certain Lines"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:" # print first 10 lines of file (emulates behavior of \"head\")\r\n awk 'NR < 11'\r\n\r\n # print first line of file (emulates \"head -1\")\r\n awk 'NR>1{exit};1'\r\n\r\n  # print the last 2 lines of a file (emulates \"tail -2\")\r\n awk '{y=x \"\\n\" $0; x=$0};END{print y}'\r\n\r\n # print the last line of a file (emulates \"tail -1\")\r\n awk 'END{print}'\r\n\r\n # print only lines which match regular expression (emulates \"grep\")\r\n awk '/regex/'\r\n\r\n # print only lines which do NOT match regex (emulates \"grep -v\")\r\n awk '!/regex/'\r\n\r\n # print any line where field #5 is equal to \"abc123\"\r\n awk '$5 == \"abc123\"'\r\n\r\n # print only those lines where field #5 is NOT equal to \"abc123\"\r\n # This will also print lines which have less than 5 fields.\r\n awk '$5 != \"abc123\"'\r\n awk '!($5 == \"abc123\")'\r\n\r\n # matching a field against a regular expression\r\n awk '$7  ~ /^[a-f]/'    # print line if field #7 matches regex\r\n awk '$7 !~ /^[a-f]/'    # print line if field #7 does NOT match regex\r\n\r\n # print the line immediately before a regex, but not the line\r\n # containing the regex\r\n awk '/regex/{print x};{x=$0}'\r\n awk '/regex/{print (NR==1 ? \"match on line 1\" : x)};{x=$0}'\r\n\r\n # print the line immediately after a regex, but not the line\r\n # containing the regex\r\n awk '/regex/{getline;print}'\r\n\r\n # grep for AAA and BBB and CCC (in any order on the same line)\r\n awk '/AAA/ && /BBB/ && /CCC/'\r\n\r\n # grep for AAA and BBB and CCC (in that order)\r\n awk '/AAA.*BBB.*CCC/'\r\n\r\n # print only lines of 65 characters or longer\r\n awk 'length > 64'\r\n\r\n # print only lines of less than 65 characters\r\n awk 'length < 64'\r\n\r\n # print section of file from regular expression to end of file\r\n awk '/regex/,0'\r\n awk '/regex/,EOF'\r\n\r\n # print section of file based on line numbers (lines 8-12, inclusive)\r\n awk 'NR==8,NR==12'\r\n\r\n # print line number 52\r\n awk 'NR==52'\r\n awk 'NR==52 {print;exit}'          # more efficient on large files\r\n\r\n # print section of file between two regular expressions (inclusive)\r\n awk '/Iowa/,/Montana/'             # case sensitive\n"})}),"\n",(0,i.jsx)(n.h3,{id:"selective-deletion-of-certain-lines",children:"Selective Deletion of Certain Lines"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:" # delete ALL blank lines from a file (same as \"grep '.' \")\r\n awk NF\r\n awk '/./'\r\n\r\n # remove duplicate, consecutive lines (emulates \"uniq\")\r\n awk 'a !~ $0; {a=$0}'\r\n\r\n # remove duplicate, nonconsecutive lines\r\n awk '!a[$0]++'                     # most concise script\r\n awk '!($0 in a){a[$0];print}'      # most efficient script\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>l,a:()=>s});var i=r(7294);const t={},a=i.createContext(t);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);